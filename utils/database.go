package utils

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"net/http"
	"projectGroup23/structs"
	"regexp"
)

// Struct DB_server - struct for database object
type DB_server struct {
	DB *sql.DB
}

// Function TodoAll - Returns all the registered todo tasks
func (s *DB_server) TodoAll(w http.ResponseWriter, r *http.Request) {
	// Create object of the todo struct
	var todolist []*structs.Todo_struct

	// Query executes a query that returns rows. In this case we use SELECT
	rows, err := s.DB.Query("SELECT Id, Title, Category, State FROM todo")

	// !! See helper.go
	ErrorCheck(w, err)

	// Next prepares the next result row for reading with the Scan method
	for rows.Next() {
		todoObj := &structs.Todo_struct{}
		// Scan copies the columns from the matched row into the values pointed at.
		rows.Scan(&todoObj.Id, &todoObj.Title, &todoObj.Category, &todoObj.State)
		// Append the created todolist object
		todolist = append(todolist, todoObj)
	}
	// To prevent further enumeration, we close the row
	rows.Close()

	// !! See helper.go
	JsonResponse(w, todolist)
}

// Function TodoCreate - Creates a todo object and pushes it into the database
func (s *DB_server) TodoCreate(w http.ResponseWriter, r *http.Request) {
	// Create object of the todo struct
	todolist := &structs.Todo_struct{}

	// Create a new decoder with the data in the body
	dec := json.NewDecoder(r.Body)
	// Decodes the values into the struct
	err := dec.Decode(&todolist)
	// TODO - Better error handling
	if err != nil {
		fmt.Println("ERROR decoding JSON - ", err)
		return
	}

	// Waits until the function is done to close the body
	defer r.Body.Close()

	// Exec will execute a query without returning anything. Here inserting into the respective columns
	// The values are represented by the "?" mark, and the actual values are retrieved from the struct object
	res, err := s.DB.Exec("INSERT INTO todo(Title, Category, State) VALUES(?, ?, ?)",
		todolist.Title, todolist.Category, todolist.State)

	// TODO - Better error handling
	if err != nil {
		fmt.Println("ERROR saving to db - ", err)
	}

	// LastInsertId returns the integer generated by the database
	lastid, err := res.LastInsertId()
	// TODO - Better error handling
	if err != nil {
		fmt.Println("ERROR fetching last id - ", err)
	}

	// Convert the last id to an int
	Id := int(lastid)
	// Push this id into the struct
	todolist = &structs.Todo_struct{Id: Id}

	// QueryRow executes a query that is expected to return at most one row. Error are defered until Scan is done.
	// Scan copies the columns from the matched row into the values pointed at.
	s.DB.QueryRow("SELECT State, Title, Category FROM Todo WHERE Id=?",
		todolist.Id).Scan(&todolist.State, &todolist.Title, &todolist.Category)

	// !! See helper.go
	JsonResponse(w, todolist)
}

// Function TodoUpdate - Used in the PUT request
func (s *DB_server) TodoUpdate(w http.ResponseWriter, r *http.Request) {
	// Create object of the todo struct
	todolist := &structs.Todo_struct{}

	// Create a new decoder with the data in the body
	dec := json.NewDecoder(r.Body)
	// Decodes the values into the struct
	err := dec.Decode(&todolist)
	// TODO - Better error handling
	if err != nil {
		fmt.Println("Error decoding JSON: ", err)
		return
	}

	// Exec will execute a query without returning anything. Here updating the respective columns
	_, err = s.DB.Exec("UPDATE todo SET Title = ?, Category = ?, State = ? WHERE Id = ?",
		todolist.Title, todolist.Category, todolist.State, todolist.Id)

	// TODO - Better error handling
	if err != nil {
		fmt.Println("Error saving to database: ", err)
	}

	// Pushes the ID from from the struct into another object
	todoObj := &structs.Todo_struct{Id: todolist.Id}

	// QueryRow executes a query that is expected to return at most one row. Error are defered until Scan is done.
	// Scan copies the columns from the matched row into the values pointed at.
	err = s.DB.QueryRow("SELECT State, Title, Category FROM todo WHERE Id=?",
		todoObj.Id).Scan(&todoObj.State, &todoObj.Title, &todoObj.Category)

	// TODO - Better error handling
	if err != nil {
		fmt.Println("Error reading from database: ", err)
	}

	// !! See helper.go
	JsonResponse(w, todoObj)
}

// Delete one todo object
func (s *DB_server) TodoDeleteObject(w http.ResponseWriter, r *http.Request) {
	// Parsing the regular expression, returns a regexp object if successful
	res, _ := regexp.Compile(`\d+$`)
	// Takes the string in the URL path
	Id := res.FindString(r.URL.Path)
	// Exec will execute a query without returning anything. ID gets matched here with "?"
	s.DB.Exec("DELETE FROM todo Where Id=?", Id)
	w.WriteHeader(http.StatusOK)
}

// TODO -- Might implement this function later -- View one todo object
func (s *DB_server) TodoObject(w http.ResponseWriter, r *http.Request) {
	fmt.Println("Implement this function if needed")
}
